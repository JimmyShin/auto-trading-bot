from __future__ import annotations

import argparse
import json
import logging
import math
import os
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Mapping, Optional, Sequence, Tuple

try:
    import yaml  # type: ignore
except Exception:  # pragma: no cover - optional dependency
    yaml = None  # type: ignore

logger = logging.getLogger("reporting.good_to_go_check")


@dataclass
class GateSpec:
    key: str
    metric_path: str
    default_threshold: str
    severity: str = "critical"


GATE_SPECS: Dict[str, GateSpec] = {
    "min_trades_rolling_30": GateSpec("min_trades_rolling_30", "rolling_windows.30.n", ">= 30", "critical"),
    "min_avg_r_atr_30": GateSpec("min_avg_r_atr_30", "rolling_windows.30.avg_r_atr", ">= 0.2", "critical"),
    "expectancy_usd_30": GateSpec("expectancy_usd_30", "rolling_windows.30.expectancy_usd", "> 0", "critical"),
    "profit_factor_30": GateSpec("profit_factor_30", "rolling_windows.30.profit_factor", ">= 1.2", "critical"),
    "max_allowed_dd_pct": GateSpec("max_allowed_dd_pct", "drawdown.max_drawdown_pct", "<= 0.20", "critical"),
    "max_error_rate_pct": GateSpec("max_error_rate_pct", "errors.error_rate_pct", "<= 1.0", "warning"),
    "max_fee_pct_of_pnl": GateSpec("max_fee_pct_of_pnl", "fees.fees_to_pnl_ratio", "<= 0.5", "critical"),
}

DEFAULT_CONFIG_PATH = Path("reporting") / "good_to_go_config.yaml"


def parse_args(argv: Optional[Sequence[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Evaluate gating rules against latest trade report")
    parser.add_argument("--report", required=True, help="Path to report JSON generated by report_metrics")
    parser.add_argument(
        "--config",
        default=str(DEFAULT_CONFIG_PATH),
        help="YAML configuration with gating thresholds",
    )
    parser.add_argument(
        "--log-level",
        default="INFO",
        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
        help="Logging verbosity",
    )
    return parser.parse_args(argv)


def load_report(path: Path) -> Dict[str, Any]:
    with path.open("r", encoding="utf-8") as handle:
        return json.load(handle)


def load_config(path: Path) -> Dict[str, Any]:
    if path.exists():
        if yaml is None:
            logger.warning("PyYAML not installed; falling back to default gating config")
        else:
            with path.open("r", encoding="utf-8") as handle:
                data = yaml.safe_load(handle) or {}
            if not isinstance(data, dict):
                raise ValueError("Gating config must be a mapping")
            return data
    return {"gates": {spec.key: spec.default_threshold for spec in GATE_SPECS.values()}}


def resolve_metric(report: Mapping[str, Any], metric_path: str) -> Any:
    current: Any = report
    for part in metric_path.split('.'):
        if isinstance(current, Mapping):
            # try exact match
            if part in current:
                current = current[part]
                continue
            # numeric key variants
            if part.isdigit() and int(part) in current:
                current = current[int(part)]
                continue
        return None
    return current


def parse_threshold(raw: Any, fallback: str) -> Tuple[str, float]:
    if isinstance(raw, (int, float)) and not isinstance(raw, bool):
        return ">=", float(raw)
    if isinstance(raw, str):
        tokens = raw.strip().split(None, 1)
        if tokens and tokens[0] in {">", ">=", "<", "<=", "==", "!="}:
            op = tokens[0]
            value_part = tokens[1] if len(tokens) > 1 else "nan"
        else:
            op = ">="
            value_part = tokens[0] if tokens else "nan"
        try:
            value = float(value_part)
        except ValueError as exc:
            raise ValueError(f"Invalid threshold value: {raw}") from exc
        return op, value
    # fallback string
    return parse_threshold(fallback, fallback)


def compare(value: Any, op: str, target: float) -> bool:
    if value is None:
        return False
    if isinstance(value, Mapping):
        return False
    try:
        numeric = float(value)
    except (TypeError, ValueError):
        return False
    if math.isnan(numeric):
        return False
    if op == ">":
        return numeric > target
    if op == ">=":
        return numeric >= target
    if op == "<":
        return numeric < target
    if op == "<=":
        return numeric <= target
    if op == "==":
        return math.isclose(numeric, target)
    if op == "!=":
        return not math.isclose(numeric, target)
    raise ValueError(f"Unsupported operator: {op}")


@dataclass
class GateResult:
    key: str
    severity: str
    status: str
    passed: bool
    value: Optional[float]
    operator: str
    target: float
    message: str

    def to_dict(self) -> Dict[str, Any]:
        return {
            "key": self.key,
            "severity": self.severity,
            "status": self.status,
            "passed": self.passed,
            "value": self.value,
            "operator": self.operator,
            "target": self.target,
            "message": self.message,
        }


def evaluate_gates(report: Dict[str, Any], config: Dict[str, Any]) -> Tuple[list[GateResult], Dict[str, Any]]:
    gate_cfg = config.get("gates", config)
    results: list[GateResult] = []
    for key, spec in GATE_SPECS.items():
        cfg_entry = gate_cfg.get(key, spec.default_threshold)
        severity = spec.severity
        threshold_def = cfg_entry
        if isinstance(cfg_entry, Mapping):
            threshold_def = cfg_entry.get("threshold", spec.default_threshold)
            severity = cfg_entry.get("severity", spec.severity)
        op, target = parse_threshold(threshold_def, spec.default_threshold)
        value = resolve_metric(report, spec.metric_path)
        passed = compare(value, op, target)
        message = f"{spec.metric_path} {value!r} {op} {target}"
        status = "pass" if passed else ("fail" if severity == "critical" else "warn")
        numeric_value = None
        try:
            numeric_value = float(value) if value is not None else None
        except (TypeError, ValueError):
            numeric_value = None
        results.append(
            GateResult(
                key=key,
                severity=severity,
                status=status,
                passed=passed,
                value=numeric_value,
                operator=op,
                target=target,
                message=message,
            )
        )
    metadata = {
        "config_keys": list(gate_cfg.keys()),
    }
    return results, metadata


def summarize(results: Sequence[GateResult]) -> Tuple[str, int, int, int]:
    fails = sum(1 for r in results if r.status == "fail")
    warns = sum(1 for r in results if r.status == "warn")
    passes = sum(1 for r in results if r.status == "pass")
    return "fail" if fails else ("warn" if warns else "pass"), fails, warns, passes


def write_artifact(report_path: Path, payload: Dict[str, Any]) -> Path:
    target = report_path.parent / "good_to_go_result.json"
    with target.open("w", encoding="utf-8") as handle:
        json.dump(payload, handle, indent=2)
        handle.write("\n")
    return target


def format_value(value: Optional[float]) -> str:
    if value is None or math.isnan(value):
        return "n/a"
    return f"{value:.4f}"


def main(argv: Optional[Sequence[str]] = None) -> int:
    args = parse_args(argv)
    logging.basicConfig(level=getattr(logging, args.log_level.upper()), format="%(levelname)s %(message)s")

    report_path = Path(args.report)
    if not report_path.exists():
        logger.error("Report file not found: %s", report_path)
        return 2

    config_path = Path(args.config)
    try:
        report = load_report(report_path)
        config = load_config(config_path)
    except Exception as exc:
        logger.error("Failed to load inputs: %s", exc)
        return 2

    results, metadata = evaluate_gates(report, config)
    summary_status, fails, warns, passes = summarize(results)

    env = report.get("environment", "unknown")
    status_text = {
        "fail": "FAIL",
        "warn": "WARN",
        "pass": "PASS",
    }[summary_status]
    print(
        f"GOOD-TO-GO {status_text}: env={env} fail={fails} warn={warns} pass={passes} report={report_path.name}"
    )

    payload = {
        "environment": env,
        "report": report_path.name,
        "status": summary_status,
        "results": [r.to_dict() for r in results],
        "metadata": {
            "config_path": str(config_path),
            **metadata,
        },
    }
    artifact_path = write_artifact(report_path, payload)
    logger.info("Gate artifact written to %s", artifact_path)

    if fails:
        return 1
    if warns:
        return 2
    return 0


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())
